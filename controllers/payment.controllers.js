import { parse } from "dotenv";
import Prisma from "../utils/dbConnection.js";
import { generateAlphaKey } from "@neylorxt/generate-unique-key";

// Create a payment intent DODODR2025-[radom8 characters]
export const createOrderAndPayment = async (req, res) => {
  /* 
    orderItems: [{orderId, productId, quantity, price}], NB: orderId is generated by the server
    billingDetails: {firstname, lastname, addressLine1, addressLine2, city, state, postalCode, country, phoneNumber, email},
    shippingDetails: {firstname, lastname, addressLine1, addressLine2, city, state, postalCode, country, phoneNumber, email},
    */
  try {
    const {
      userId,
      orderItems,
      billingDetails,
      shippingDetails,
      additionalInfo,
      currency = "CAD",
    } = req.body;

    let subTotal = 0;

    //create a unique orderId
    const date = new Date();
    const orderId = `DODODR${date.getFullYear()}-${generateAlphaKey(
      8,
      "-",
      4
    )}`;

    // Calculate subtotal amount
    orderItems.forEach((item) => {
      subTotal += item.price * item.quantity;
    });

    // calculate taxes + total amount
    // Assuming GST is 5% and QST is 9.975% for Canada
    let GST = (5 / 100) * subTotal;
    let QST = (9.975 / 100) * subTotal;
    let tax = GST + QST;
    let totalAmount = subTotal + GST + QST;
    totalAmount = parseFloat(totalAmount.toFixed(2));

    // create orderItems in the database
    const orderItemsData = orderItems.map((item) => ({
      orderId,
      productId: item.productId,
      quantity: item.quantity,
      price: item.price,
    }));

    const createOrderItems = await Prisma.orderItem.createMany({
      data: orderItemsData,
      skipDuplicates: true, // Skip duplicates if any
    });

    if (!createOrderItems) {
      throw new Error("CreateOrderItemsError");
    }

    console.log("Order items created:", createOrderItems);

    //create order in database
    const createOrder = await Prisma.order.create({
      data: {
        id: orderId,
        userId: parseInt(userId),
        totalPrice: totalAmount,
        status: "pending",
        subtotal: parseFloat(subTotal.toFixed(2)),
        tax: parseFloat(tax.toFixed(2)),
        currency,
        additionalInfo,
        billingFirstName: billingDetails.firstname,
        billingLastName: billingDetails.lastname,
        billingAddressLine1: billingDetails.addressLine1,
        billingAddressLine2: billingDetails.addressLine2,
        billingCity: billingDetails.city,
        billingState: billingDetails.state,
        billingPostalCode: billingDetails.postalCode,
        billingCountry: billingDetails.country,
        billingPhoneNumber: billingDetails.phoneNumber,
        billingEmail: billingDetails.email,
        shippingFirstName: shippingDetails.firstname,
        shippingLastName: shippingDetails.lastname,
        shippingAddressLine1: shippingDetails.addressLine1,
        shippingAddressLine2: shippingDetails.addressLine2,
        shippingCity: shippingDetails.city,
        shippingState: shippingDetails.state,
        shippingPostalCode: shippingDetails.postalCode,
        shippingCountry: shippingDetails.country,
        shippingPhoneNumber: shippingDetails.phoneNumber,
        shippingEmail: shippingDetails.email,
      },
    });
    if (!createOrder) {
      throw new Error("CreateOrderError");
    }

    console.log("Order created:", createOrder);

    // Create a payment intent with Stripe
    const paymentIntent = await Stripe.paymentIntents.create({
      amount: totalAmount * 100, // Stripe expects the amount in cents
      currency: currency.toLowerCase(),
      metadata: {
        orderId: orderId,
        userId: userId,
        customerEmail: billingDetails.email,
        customerPhone: billingDetails.phoneNumber,
        itemCount: orderItems.length,
        customerName: `${billingDetails.firstname} ${billingDetails.lastname}`,
        additionalInfo: additionalInfo || "",
      },
      description: `Payment for order ${orderId}`,
      automatic_payment_methods: {
        enabled: true,
      },
    });

    // create payment in the database
    const createPayment = await Prisma.payment.create({
      data: {
        id: paymentIntent.id,
        orderId: orderId,
        userId: parseInt(userId),
        amount: totalAmount,
        currency,
        status: paymentIntent.status,
        paymentMethod: paymentIntent.payment_method_types[0],
        transactionId: paymentIntent.charges.data[0]?.id || null,
        gatewayResponse: JSON.stringify(paymentIntent),
      },
    });

    if (!createPayment) {
      throw new Error("CreatePaymentError");
    }

    res.status(200).json({
      message: "Order and payment created successfully",
      orderId: orderId,
      paymentIntent: paymentIntent,
      createOrder,
      createPayment,
    });
  } catch (error) {
    if (error.type === "StripeInvalidRequestError") {
      return res.status(400).json({
        error: "Invalid request to Stripe: " + error.message,
      });
    }
    if (error.type === "StripeCardError") {
      return res.status(402).json({
        error: "Card declined: " + error.message,
      });
    }

    if (error.type === "StripeAPIError") {
      return res.status(500).json({
        error: "Stripe API error: " + error.message,
      });
    }
    if (error.message === "CreatePaymentError") {
      return res.status(500).json({
        error: "Error creating payment in the database",
      });
    }
    if (error.message === "CreateOrderItemsError") {
      return res.status(500).json({
        error: "Error creating order items in the database",
      });
    }
    if (error.message === "CreateOrderError") {
      return res.status(500).json({
        error: "Error creating order in the database",
      });
    }
    console.error("Error creating order and payment:", error);
    return res.status(400).json({
      error: "Error when creating order and payment " + error.message,
    });
  }
};
